// JavsScript - может управлять внешними видомости сайта и делать так, чтобы страница реагировала на нажатие клавиши или перемещение мышки.
//              JS использует для облегчение работы с почтой, отправки комментариев или улучения навигации.
// 				 Применяется как сценарий в браузере предание интерактивностии в веб-странице.


// Снтаксис - (структура) правила указывающих как объединять символы и слова, чтобы составить робатоюшую программу.

// Строгий режим — "use strict"

/*

		На протяжении долгого времени JavaScript развивался без проблем с обратной совместимостью. 
	Новые функции добавлялись в язык, в то время как старая функциональность не менялась.

		Преимуществом данного подхода было то, что существующий код продолжал работать. А недостатком – что любая ошибка 
	или несовершенное решение, принятое создателями JavaScript, застревали в языке навсегда.

		Так было до 2009 года, когда появился ECMAScript 5 (ES5). Он добавил новые возможности 
	в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, 
	по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".

	«use strict»
	Директива выглядит как строка: "use strict" или 'use strict'. 
	Когда она находится в начале скрипта, весь сценарий работает в «современном» режиме.

*/


// ПЕРЕМЕННЫЕ -  это область памяти которое храниться какито данные (let , var)
// https://learn.javascript.ru/variables

// Имя переменное: Let name: может содержать только латинское
//                           цифры и символы
//                           первый не должен быть цифрый
// 					  	   	 переменные с именами apple и APPLE – это две разные переменные.
// 								  let, class, return и function зарезервированы, код даёт синтаксическую ошибку:

	let surname="Ainadinov";
	var name="Adilet";

// КОНСТАНТА (постоянный) - это тоже переменная которое нельзя изменить (почти)
	const ry="Tabin";



// ОПЕРАТОРЫ - обозначают операцию которую нужно произвести. 
// https://learn.javascript.ru/operators

// Операнд - это то к чему применяется оператор
			let userAge2=40-3; 
// 				40-3; - это операнды


//   1) Базовые - математические 
//  		-- Бинарный - операторы которые применяются к двум операндам
			let userAge1=50-5;
// 			бинарный оператор '+' применить к строкам, то он их объединяет в одну:
			let s = "моя" + "строка";
			console.log(s); // моястрока

// 		-- Унарный - оператор который применен только к одном операнду
			let userAge=55;
// 			оператор унарный минус "-" меняет знак числа на противоположный:
			let x = 1;
			x = -x;
			console.log( x ); // -1, применили унарный минус

// 			Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. 
// 			Но если операнд не число, унарный плюс преобразует его в число.
			let apples = "2";
			let oranges = "3";

// 			оба операнда предварительно преобразованы в числа
			console.log( +apples + +oranges ); // 5

// 		JS поддерживается следующие операторы:
				// Сложение
					let slozh=5+8;

				// Вычитание
					let vichet=8-6;

				// Умножение
					let umnozh=8*2;

				// Деление
					let del=8/4;

				// Взятие остатка от деления
					let vziatOstOtDel=11%2;
				
				// Возведение в степень
					let vozStep=5*5*5;

// 		Специальные возможности Операторов:
				// Применение оператора сложения к строкам:
				let One="a"+"b"+"c";
				console.log(One);

				// Если хотябы один операнд будеть строкой, то все результат тоже будеть строкой.
					let Two= 50+"abc";
					console.log(Two);

				// Порядок не имеет значения
				// Операции до сложения со строкой выполняются как обычно.
					let Three=52-20+"abc";
					console.log(Three);

				// Другие арифметические операторы работает только с числами
					let Four="25"-5;
					console.log(Four);
				
			// Приоритет Операторов
					// Разный приоритет
					let Five=2-1*5;
					console.log(Five);

					// Скобки
					let Six=(2-1)*5;
					console.log(Six);

					// Одинаковый приоритет
					let Seven=2-1+5;
					console.log(Seven);

					// Приоритет операторов
					/*

						1	унарный плюс	      +
						1	унарный минус	      -
						2	возведение в степень	**
						3	умножение	         *
						3	деление	            /
						4	сложение             +
						4	вычитание            -
						2	присваивание	      =

					*/
	
			// Инкримент / Декримент
				// Инкримент - улучает на единидцу
					let addUser=2;
						addUser++;
					console.log(addUser);	

				// Деримент - уменчает на единидцу
					let addUser1=2;
					addUser1--;
					console.log(addUser1);	


				// Постфиксная и префиксная форма
					// Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:
					let counters = 0;
					counters++;
					++counters;
					console.log( counters ); // 2, обе строки сделали одно и то же

					// Если хочется тут же использовать результат, то нужна префиксная форма:
					let counter = 0;
					console.log( ++counter ); // 1

//   2) Оператор сравнения
			let a=5;
			let b=4;
			// больше
			console.log(6>5);
			// меньше
			console.log(6>7);
			// больше\равно
			console.log(a>=b);
			// меньше\равно
			console.log(a<=b);
			// равно
			console.log(a==b);
			// не равно
			console.log(a!=b);
			// строгое равно
			console.log(a===b);
			// строгое не равно
			console.log(a!==b);

			// Оператор сравнения возвращают логический тип данных со значением (TRUE) или (FALSE).
				console.log(2>1);
				console.log(4<2);

			// Сравнение строк - чтобы определить одно строка больше другой JS исползуеть Альфавитный порядок.
				console.log("ab">"aa");
				// маленкие буквы больше чем большие
				// количестко строк имет значений
				// сначала сравниваются первые символы строк

			// Сравнение разных типов данных:
				console.log("58">10);
				// при таких сравнений JS приводит их число


//  3) Логические операторы
// https://learn.javascript.ru/logical-operators

		// 1) ИЛИ (||) ПАЙПС
				console.log(true||false);
				console.log(false||true);
				console.log(false||false);
				console.log(true||true);
			// вычеляет операнды слева направо
			// каждый операнд конвен-я логическое значение
			// если результать(true), то выведит (true). Если все опер-ды (false), воз-ет последное значение.

		// 2) И (&&) АМПЕРСАНД 
				console.log(true&&false);
				console.log(false&&true);
				console.log(false&&false);
				console.log(true&&true);
			// вычеляет операнды слева направо
			// каждый операнд конвен-я логическое значение
			// если результать(false), то выведит (false). Если все опер-ды (true), воз-ет последное значение.

			// Приоритет (&&) больше чем (||).
				console.log(1&&0||2&&1);
		
		// 3) НЕ (!)  
				console.log(!true);
			// сначала приводит аргумент к логическому типу (true|false)
			// затем возвращает противоположное значение(reverse)
			// Оператор (! НЕ) имеет наивысший приоритет. Он всегда выполняется первым перед (&&,||).
 				console.log(!true&&58||18&&1);

		// 4)	Оператор нулевого слияния (??) 
				let nol = null;	
				console.log(nol ?? "Аноним");
			// это быстрый способ выбрать первое «определённое» значение из списка. 
			// значение «определенное», если оно не равняется ни null, ни undefined. 
			// возвращает первый аргумент, если он не null/undefined, иначе второй. 
			// JS запрещает использование оператора ?? вместе с && и ||, если не указан при помощи круглых скобок.

		// 5) Оператор опциальный цепочки (?.)
				const box = document.querySelectorAll('.data')
				console.log(box?.textContents)
			// предназначено для того чтобы проверит существует ли элемент внутри блока по вложенности
			// если не находить данные вернеть underfined  
			// оператор проверить часть слево от себя если она существует тогда код пойдет дальше проверять елси нет то вернеть underfined

// ТИПЫ ДАННЫХ - это информация, которая хранится в наших комп.прогамах.
//            JS данные: 
// 							1) Числа - предс значения как в виде целых чисел, таки и виде с плавающей точкой.
									let num=56;
									let num1=2.98;
									// Infinity представляет собой математическую бесконечность ∞. 
									// Мы можем получить его в результате деления на ноль:
										console.log( 1 / 0 ); 

// 							2) Строки - набор букв и символов, цифр, знаков пунктуации и пробелов. Чтобы JS знал где начинается и зоканчивается строка,   												е берут в ("...");
									let stringFirst="string";
									// Двойные кавычки: "Привет".
									// Одинарные кавычки: 'Привет'.
									// Обратные кавычки: `Привет`.
										// Обратные же кавычки имеют расширенную функциональность. 
										// Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:

										let nameI = "Иван";
										console.log( `Привет, ${nameI}!` ); // Привет, Иван!

										// Выражение внутри ${…} вычисляется, и его результат становится частью строки. Мы можем положить туда всё, 
										// что угодно: переменную name, или выражение 1 + 2, или что-то более сложное.
																		
// 							3) Булевые - это логический тип можеть принять только два значение true|false
									console.log(!true);

// 							4) Underfined -  неопределенный тип.
									let userName;

// 							5) Null - содержит только одно значение Null (нулевой,ничего)
									let Null;

// 							6) NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
									console.log( "не число" / 2 );

// 							7) Symbol -  это уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов. 
									// - уникальнест
									// - неизменаемый
									const smb = Symbol("hi")
									console.log(smb)
									
						       		const myAwesomeDB = {
										movies: [],
										actors: [],
										[Symbol("id")]: 12342,
									}

									// Сторонний код библиотеки
									myAwesomeDB.id ='2111234';

									console.log(myAwesomeDB["id"])
									console.log(myAwesomeDB)
							
// 							8) BigInt - это встроенный объект, который представлять целые числа больше 253 - 1, 
// 										наибольшего числа которое JavaScript может надёжно представить с Number примитивом. 
// 										Это максимальное значение можно получить, обратившись к Number.MAX_SAFE_INTEGER.
											// Константа MAX_SAFE_INTEGER имеет значение 9007199254740991.

										const bigint = 1234567890123456789012345678901234567890n;
											  	console.log(bigint)

										const sameBigint = BigInt("1234567890123456789012345678901234567890");
												console.log(sameBigint)

										const bigintFromNumber = BigInt(10);
												console.log(bigintFromNumber)

									// Математические операторы
										// BigInt можно использовать как обычные числа, к примеру:
										console.log(1n + 2n); // 3

										// В математических операциях мы не можем смешивать bigint и обычные числа:
											// console.log(1n + 2); // Error: Cannot mix BigInt and other types
										// Мы должны явно их конвертировать: используя либо BigInt(), либо Number()
										// К BigInt числам нельзя применить унарный оператор +

									// Операции сравнения
										// Операции сравнения, такие как <, >, работают с bigint и обычными числами как обычно:
										console.log( 2n > 1n ); // true
										console.log( 2n > 1 ); // true
										// обычные и bigint числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении ==:
										console.log( 1 == 1n ); // true
										console.log( 1 === 1n ); // false
										// любом другом логическом операторе bigint число ведёт себя как обычное число.



// Взаимодействие: alert, prompt, confirm
// Так как мы будем использовать браузер как демо-среду, нам нужно познакомиться 
// с несколькими функциями его интерфейса, а именно: alert, prompt и confirm.

 	alert("Hello");

/*

	Это небольшое окно с сообщением называется модальным окном. Понятие модальное означает, 
	что пользователь не может взаимодействовать с интерфейсом остальной части страницы,
	нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном.
 	В данном случае – пока не будет нажата кнопка «OK».

*/

	// Функция prompt принимает два аргумента:

	// result = prompt(title, [default]) ;

	let age = prompt('Сколько тебе лет?', 100);

	alert(`Тебе ${age} лет!`);

/*

	Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

	title - Текст для отображения в окне.
	default - Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.

*/

	// confirm

// result = confirm(question);

/*

	Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
	Результат – true, если нажата кнопка OK. В других случаях – false.

*/

	let isBoss = confirm("Ты здесь главный?");
	alert( isBoss ); // true, если нажата OK

// ОБЪЕКТЫ - могут содержат целый коллекций строк, очень похож на массивы
/*

		Объекты же используются для хранения коллекций различных значений и более сложных сущностей. 
	В JavaScript объекты используются очень часто, это одна из основ языка. Поэтому мы должны понять их, прежде чем углубляться куда-либо ещё.

		Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. 
	Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.

		Мы можем представить объект в виде ящика с подписанными папками. Каждый элемент данных хранится в своей папке, 
	на которой написан ключ. По ключу папку легко найти, удалить или добавить в неё что-либо.

*/

let user={
	name:"vase",
	age:23,
};
// Добавим новое ключей  значение
user.city = "Aqtobe";

console.log(user);
console.log(user.name); console.log(user[1]);

let user1={
	name:"ivan",
	age:40,
	city:"aqtobe",
};

// Для удаления свойства мы можем использовать оператор delete:
delete user1.age
console.log(user1["city"]);

// Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:
let user2={
	name:"ivan",
	age:40,
	city:"aqtobe",
	address:{
		street:"Abay",
		flat:1,
	},	
	"likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};
// Последнее свойство объекта может заканчиваться запятой:
// Это называется «висячая запятая». Такой подход упрощает добавление, 
// удаление и перемещение свойств, так как все строки объекта становятся одинаковыми.

// Квадратные скобки
// Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
// Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. 
// Такой способ сработает с любым именем свойства:
let user4 = {
	name:"ivan",
	age:40,
	city:"aqtobe",
};

// присваивание значения свойству
user4["likes birds"] = true;

// получение значения свойства
console.log(user4["likes birds"]); // true

// удаление свойства
delete user4["likes birds"];

// Копирование объектов и ссылки
/*

	Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся 
	и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения 
	и т.д. – всегда копируются «как целое значение».

*/
// При копировании переменной объекта копируется ссылка, но сам объект не дублируется.
	let userCop = { name: "John" };

	let adminCop = userCop; // копируется ссылка
// Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:

// Клонирование и объединение, Object.assign
// Синтаксис
	// Object.assign(dest, [src1, src2, src3]);

/*

	 Первый аргумент dest — целевой объект.
	 Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
	 Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, 
	свойства всех аргументов, начиная со второго, копируются в первый объект.
	 Возвращает объект dest.

*/
	let userClone = { name: "John" };

	let permissions1 = { canView: true };
	let permissions2 = { canEdit: true };

	// копируем все свойства из permissions1 и permissions2 в userClone
	Object.assign(userClone, permissions1, permissions2);

	// теперь userClone = { name: "John", canView: true, canEdit: true }

// Методы Объектов
	//Object.values()t — позволяет получить все значения, заключенные в объекте.
		const userData1 = {
			name: "John",
			age: 25,
			isOnline: true
		}
		console.log(Object.values(userData1)); //возвращает ["John", 25, true]

	// Метод Object.entries() — возвращает многомерный массив, содержащий как ключи, так и значения объекта. Нужно просто передать имя объекта в качестве аргумента для метода.
		const userData2 = {
			name: "John",
			age: 25,
			isOnline: true
		}
		console.log(Object.entries(userData2)); //возвращает: [["name", "John"], ["age", 25], ["isOnline", true]]

	// Метод Object.keys() - возвращает массив, содержащий все ключи внутри объекта и передаваемый в качестве аргумента.
		const person1 = {
			name: "James",
			age: 28,
			available: false
		}
		console.log(Object.keys(person1)); //возвращает: ["name", "age", "available"]

	//Object.freeze() позволяет заморозить объект, передаваемый ему в качестве аргумента. После этого нельзя будет обновить объект или добавить ему новые свойства.
		const person2 = {
			name: "Alex",
			age: 35,
			available: true
		}
		//Заморозка объекта
			Object.freeze(person2);
			
		//Обновление и добавление новых свойств.
			person2.name = "John";
			person2.newProp = "Developer";
			console.log(person2); //возвращает{name: "Alex", age: 35, available: true}
		// Несмотря на попытку обновить объект person и добавить ему новые свойства, он не изменился, потому что уже заморожен методом Object.freeze().
	
	// Object.seal() предотвращает добавление новых свойств к объекту. Он похож на Object.freeze() с той лишь разницей, что позволяет обновлять и изменять свойства внутри объекта.
		const userData3 = {
			name: "Brad",
			age: 28,
			isOnline: false
		}
		//Использование метода 
		Object.seal(userData3);
		//Обновление свойства.
		userData3.isOnline = true;
		//Добавление свойства.
		userData3.active = false;
		console.log(userData3); //возвращает {name: "Brad", age: 28, isOnline: true}

	


//СТРОКИ В JavaScript

// Одинарные '....';
	let string='Привет!';
	console.log(string);
// Двойные   "....";
	let string2="Привет!";
	console.log(string2);
// Обратные  `....`;
	let string3="Привет!";
	console.log(string3);
// Многострочный запис \n
	let string4="Привет! \nВы на канале Фрилансер по жизни!";
	console.log(string4);
// Табуляция(отступ) \+
	let string5="Привет! \n\+Вы на канале Фрилансер по жизни!";
	console.log(string5);
// Обратный слеш \\
	let string6="Привет! \\Вы на канале Фрилансер по жизни!";
	console.log(string6);
// Обратный слеш \' \"
	let string7="Привет!\n\"Вы на канале Фрилансер по жизни!\"";
	console.log(string7);


// Свойтсво строк
	let srtsvo="hello";
// .length-длина строки
	console.log(srtsvo.length);
// .tоUpperCase()-большой регистр
	console.log(srtsvo.toUpperCase());
// .toLowerCase()-нижный регистр
	console.log(srtsvo.toLowerCase());
// .slice(2 1)-возвращает часть строки от старт до енд
	console.log(srtsvo.slice(1, 4));
// .indexOf()-пойск элемента
	console.log(srtsvo.indexOf("lo"));
	console.log(srtsvo.indexOf("lo"));
	console.log(srtsvo.indexOf("o"));
	console.log(srtsvo.indexOf("p"));








// МАССИВЫ-позваляет создавать и групировать данные более легким способом. Чтобы групировать данные в один спиок

//Синтаксис
	let arrOne=[
		"Alex",
		"Kate",
		"Steve",
		{
			color:"red",
			age:36	
		},
		function(){
			console.log("Hello World");
		}
	];
	console.log(arrOne);

// Многократный массивы:
	let arrTwo=[
		[55,44,55],
		[88,99,14],
		[22,78,65],
	]

// Получение значений:
	console.log(arrOne[0]);
	console.log(arrOne[3].age);
	console.log(arrTwo[2][2]);

// Изменение элемента:
	arrOne[0]="Kolia";
	console.log(arrOne)

// Методы массива:
let arrThree=[
	"Alex",
	"Kate",
	"Steve",
]
	// .push()-добавить элемент в конец массива
	arrThree.push("Olga","Sergei")
	console.log(arrThree);

	// .pop()-удальяет элемент в конце массива
	arrThree.pop()
	console.log(arrThree);

	// .shift()-удальяет элемент в начале массива
	arrThree.shift()
	console.log(arrThree);

	// .unshift()-добавить элемент в начале массива
	arrThree.unshift("Vlad")
	console.log(arrThree);

	// delete arr[]-удаление/добавление/изменение конкретного элементе масcива
	delete arrThree[1];
	console.log(arrThree);

	// .splice(index, del, elem1)- позиционное удаление/добавление/изменение конкретного элементе масcива
	// index-стартовое позиция элемента которое начинается
	// del-количество элемента которое хотим удалить
	// elem1-заменить элемент
	// (1,0, )-добавить новый элемент
		
	// Удаляем элемент
	let arrOnes = ['Ваня', 'Иштван', 'Оля',];
	// Начиная с первой позиции (Иштван), удаляем один элемент
	arrOnes.splice(1, 1);
	console.log(arrOnes);

	// Удаляем элемент и возвращаем его в переменную
	let arrTwos = ['Ваня', 'Иштван', 'Оля',];
	let removed = arrTwos.splice(1, 1);
	console.log(removed);

	// Заменяем элементы
	let arrThrees = ['Ваня', 'Иштван', 'Оля',];
	// Начиная с нулевой позиции (Ваня), заменяем один элемент
	arrThrees.splice(0, 1, 'Коля');
	console.log(arrThrees);

	// Добавляем элементы
	let arrFours = ['Ваня', 'Иштван', 'Оля',];
	// Начиная с первой позиции (перед 'Иштван'), добавляем два элемента
	arrFours.splice(1, 0, 'Коля', 'Маша');
	console.log(arrFours);

	// Удаляем элемент
	let arrFives = ['Ваня', 'Иштван', 'Оля',];
	// Начиная с последней позиции (Оля), удаляем один элемент
	arrFives.splice(-1, 1);
	console.log(arrFives);

	// .slice - создаёт новый массив в который копирует часть либо вес массив.
	let arrFour=[
		"Alexe",
		"Kates",
		"Steved",
		"Mark",
	]
	arrFour.slice(1,3);
	console.log(arrFour.slice(1,3));

	// Синтаксис arr.slice([start], [end]) Не включая [end]

	// Копируем часть массива
	let arrOnec = ['Ваня', 'Иштван', 'Оля',];

	// Начиная с 1й позиции 'Иштван',
	// до 2й позиции 'Оля' (не включая)
	let arrTwoc = arrOnec.slice(1, 2);
	console.log(arrTwoc);

	// Начиная с предпоследней позиции 'Иштван',
	// до последней 'Оля' (не включая)
	let arrThreec = arrOnec.slice(-2, -1);
	console.log(arrThreec);

	// Копируем весь массив
	let arrFourc = arrOnec.slice();
	console.log(arrFourc);


	// .concat - создаёт новый массив в который копирует данные из других массивов и доп.значения(в конец) (Объединение масивов)
	// Синтаксис arr.concat(arg1, arg2...)

	let arrOnet = ['Ваня', 'Иштван', 'Оля',];
	let arrTwot = arrOnet.concat('Петя');
	console.log(arrTwot);


	// Пойск в массиве 
	// Методы indexOf/lastIndexOf и includes
	// пойск элемента в массиве
	/*
	1. arr.indexOf(item, from) ищет item, начиная с индекса from,
		и возвращает индекс, на котором был найден искомый
		элемент, в противном случае - 1.
	2. arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
	3. arr.includes(item, from) – ищет item, начиная с индекса from,
		и возвращает true, если поиск успешен.
	*/

	let arrof = ['Ваня', 'Иштван', 'Оля',];

	// indexOf
	console.log(arrof.indexOf('Иштван'));
	console.log(arrof.indexOf('Вася'));
	console.log(arrof.indexOf('Иштван', 2));

	// includes
	console.log(arrof.includes('Иштван'));
	console.log(arrof.includes('Вася'));
	console.log(arrof.includes('Иштван', 2));


	// find и findIndex
	// поиск в массиве объектов с пределённым условием


	// Синтаксис
		// 	let result = arr.find(function(item, index, array) {
		// если true - возвращается текущий элемент и перебор прерывается
		// если все итерации оказались ложными, возвращается undefined
		// });

	let arrfind = [
		{ name: 'Вася', age: 36 },
		{ name: 'Коля', age: 18 },
		{ name: 'Оля', age: 'Не скажу' },
	]

	let resultOne = arrfind.find(function (item, index, array) {
		return item.age === 18;
	});

	//let resultOne = arrfind.find(item => item.age === 18);
	console.log(resultOne);
	
	
	// filter
	// Метод ищет все элементы, на которых функция-колбэк вернёт true.
	/*
	let results = arr.filter(function (item, index, array) {
		если true - элемент добавляется к результату, и перебор продолжается
		возвращается пустой массив в случае, если ничего не найдено
	});
	*/
	
	let arrfilter = [
		{ name: 'Вася', age: 36 },
		{ name: 'Коля', age: 18 },
		{ name: 'Оля', age: 'Не скажу' },
	]
	let resultfilter = arrfilter.filter(function (item, index, array) {
		return item.age >= 18;
	});
	console.log(resultfilter);
	

	// Сортировка в массивов
	// Метод sort(fn)
	// сортирует массив на месте, меняя в нём порядок элементов.
	// Сотритовка слов
	let arrOnesort = ['Иштван', 'Ваня', 'Оля'];
	console.log(arrOnesort.sort());

	// Сотритовка чисел
	let arrTwosort = [8, 22, 1,];
	console.log(arrTwosort.sort());

	// По умолчанию элементы сортируются как строки.
	// Для строк применяется лексикографический порядок,
	// и действительно выходит, что "8" > "22".
	console.log("8" > "22");

	// Функция сортировки

	function compareNumeric(a, b) {
		console.log(`Сравниваем ${a} и ${b}`);
		if (a > b) return 1;
		if (a == b) return 0;
		if (a < b) return -1;

		//return a - b
	}

	console.log(arrTwosort.sort((a, b) => a - b));

	console.log(arrTwosort.sort(compareNumeric));

	// Метод reverse
	// меняет порядок элементов в массиве на обратный.

	let arrOnerev = ['Ваня', 'Иштван', 'Оля'];
	console.log(arrOnerev.reverse());

	// Преобразование массивов
	// Метод map.
	// вызывает функцию для каждого элемента массива 
	// и возвращает массив результатов выполнения этой функции.

		// let resultmap = arr.map(function(item, index, array) {
			// возвращается новое значение вместо элемента
		// });

	let arrmap = ['Ваня', 'Иштван', 'Оля',];

	let resultmap2 = arrmap.map(function (item, index, array) {
		return item[0];
	});
	//let result = arr.map(item => item[0]);
	console.log(arrmap);
	console.log(resultmap2);

	
	// Метод split преобразовывает строку в
	// массив по заданному разделителю
	// Синтаксис: str.split(delim)
	
	let strsplit = 'Ваня,Иштван,Оля';

	let arrsplit = strsplit.split(',');
	console.log(arrsplit);


	// Можно ограничить кол-во объектов
	// которые попадут в массив

	let arrTwosplit = strsplit.split(',', 2);
	console.log(arrTwosplit);


	
	// Метод join преобразовывает массив в
	// строку c заданным разделителем
	// Синтаксис: arr.join(glue)


	let arrjoin = ['Ваня', 'Иштван', 'Оля',];
	let srtjoin = arrjoin.join('.');
	console.log(srtjoin);


	// Перебор элементов

	let arrfor = ['Ваня', 'Иштван', 'Оля',];
	console.log(arrfor.length);

	// Цикл FOR
	for (let i = 0; i < arrfor.length; i++) {
		console.log(arrfor[i]);
	}
	
	// Цикл FOR...OF
	// Можно использовать для вывода значений
	let arrof2 = ['Ваня', 'Иштван', 'Оля',];

	for (let arrItem of arrof2) {
		console.log(arrItem);
	}
	


	// Метод перебора forEach
	// Выполняет функцию для каждого элемента массива
	
	arrOne.forEach(function (item, index, array) {
		// ... делать что-то с item
	});
	

	
	let arrEach = ['Ваня', 'Иштван', 'Оля',];

	arrEach.forEach(function (item, index, array) {
		console.log(`${item} находится на ${index} позиции в ${array}`);
	});
	
	
	// Стрелочная функция
	arrEach.forEach((item, index, array) => {
		console.log(`${item} находится на ${index} позиции в ${array}`);
	});

	// Методы reduce/reduceRight

	/*
	Итак, мы выяснили что если нам нужно перебрать
	массив – мы можем использовать forEach, for или for..of.
	Если нам нужно перебрать массив и вернуть
	данные для каждого элемента – мы используем map.

	Методы arr.reduce и arr.reduceRight похожи на эти методы,
	но они немного сложнее и используются для вычисления
	какого-нибудь единого значения на основе всего массива.
	*/

		// Синтаксис
		let value = arrOne.reduce(function(previousValue, item, index, array) {
		// ...
		}, 0);

	/*
	К привычным нам аргументам item, index, array
	добавляется previousValue:

	previousValue – результат предыдущего вызова этой функции,
	равен initial при первом вызове (если передан initial),
	item – очередной элемент массива,
	index – его индекс,
	array – сам массив.

	Функция применяется по очереди ко всем элементам
	массива и «переносит» свой результат на следующий вызов.
	*/


	
	let arrOneredu = [1, 2, 3, 4];
	let reduceValueOne = arrOneredu.reduce(function (previousValue, item, index, array) {
		return item + previousValue;
	}, 0);
	console.log(reduceValueOne);

	/*
	Шаг №1
	previousValue = 0
	item = 1
	их сумма = 1

	Шаг №2
	previousValue = 1
	item = 2
	их сумма = 3

	Шаг №3
	previousValue = 3
	item = 3
	их сумма = 6

	Шаг №4
	previousValue = 6
	item = 4
	их сумма = 10
	*/
	

	let arrArrow = [1, 2, 3, 4];
	let reduceValueArrow = arrArrow.reduce((pValue, item) => item + pValue, 0);
	console.log(reduceValueArrow);
	
	let arrTwored = ['Ваня', 'Иштван', 'Оля',];

	// Если не указать начальное значение, то оно будет равно
	// первому элементу массива (previousValue=Ваня)
	// А работа метода начнется со второго элемента (item=Иштван)
	
	let reduceValueTwo = arrTwored.reduce(function (previousValue, item, index, array) {
		console.log(previousValue);
		console.log(item);
		return `${item}, ${previousValue}`;
	});
	console.log(`Пользователи: ${reduceValueTwo}`);

// MAP – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа значение.
	// Методы и свойства:
		// new Map() – создаёт коллекцию.
			const map = new Map();
			console.log(map);
		// map.set(key, value) – записывает по ключу key значение value.
			map.set("1", "str1"); 
			map.set("2", "str2"); 
			console.log(map);
		// map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
			console.log(map.get("1"))
		// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
			console.log(map.has("1"))
		// map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
			map.delete("1")
			console.log(map)
		// map.size – возвращает текущее количество элементов.	
			console.log(map.size)
		// map.clear() – очищает коллекцию от всех элементов.
			const map1 = new Map();
			map1.set("2", "str2"); 
				map1.clear()
				console.log(map1)

	// Перебор Map
		// map.keys() – возвращает итерируемый объект по ключам,
		// map.values() – возвращает итерируемый объект по значениям,
		// map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

		let recipeMap = new Map([
			["огурец", 500],
			["помидор", 350],
			["лук",    50]
		]);

		// перебор по ключам (овощи)
		for (let vegetable of recipeMap.keys()) {
			console.log(vegetable); // огурец, помидор, лук
		}

		// перебор по значениям (числа)
		for (let amount of recipeMap.values()) {
			console.log(amount); // 500, 350, 50
		}

		// перебор по элементам в формате [ключ, значение]
		for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
			console.log(entry); // огурец,500 (и так далее)
		}

	// Object.entries(obj) - Если у нас уже есть обычный объект, и мы хотели бы создать Map из него, то поможет встроенный метод Object.entries(obj), который получает объект и возвращает массив пар ключ-значение для него, как раз в этом формате.
		// 	Так что мы можем создать Map из обычного объекта следующим образом:
		
		let objMap = {
		  name: "John",
		  age: 30
		};
		
		let map3 = new Map(Object.entries(objMap));
		console.log(map3)
	
	// Object.fromEntries - чтобы получить обычный объект из Map.
		// К примеру, у нас данные в Map, но их нужно передать в сторонний код, который ожидает обычный объект.
	
		let map4 = new Map();
		map4.set('banana', 1);
		map4.set('orange', 2);
		map4.set('meat', 4);
		
		let obj4 = Object.fromEntries(map4); // создаём обычный объект (*)
		console.log(obj4)

// Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
	// Его основные методы это:
		// new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
			let set = new Set();
			console.log(set)
		// set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
			set.add("John");
			set.add("Pete");
			set.add("Mary");
			set.add("John");
			set.add("Mary");
			console.log(set)
		// set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
			console.log(set.delete("Mary"), set)
		// set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
			console.log(set.has("Mary"), set)
		// set.clear() – удаляет все имеющиеся значения.
			const set1 = new Set();
			let maryy = { name: "Mary" };
			set1.add(maryy); 
				set1.clear()
				console.log(set1)
		// set.size – возвращает количество элементов в множестве.
			console.log(set.size)

	// Перебор объекта Set
		// Set имеет те же встроенные методы, что и Map:

		// set.keys() – возвращает перебираемый объект для значений,
		// set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
		// set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

		// Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:
		let set2 = new Set(["апельсин", "яблоко", "банан"]);

		for (let value of set2) {
			console.log(value);
		}
		// то же самое с forEach:
		set2.forEach((value, valueAgain, set) => {
			console.log(value);
		});


// ФУНКЦИЯ - фрагмент кода, к которому можно обратиться из другого место программы.(Действие) Механизм для многократного использования частей кода.
//         - позволяет запускть один и тот же код из разных мест программы без необходимости его копировать.

// Синтаксис:
	function FuncFirst(){ // Имя фунций(Аргумент)
		console.log("Делаем что-то"); //(тело функции)
	};

	let ourFirstFunction=function(){
		console.log("hello world!");
	}
	// Вызов функции:
	ourFirstFunction();

	// Аргумент - чтобы функция могло изменить поведение в зависимости от значений.
	// Если параметр не указан, то его значением становится undefined.
	let sayHelloTo=function(Nick){
		console.log("hello,"+Nick+"!");
	};
	sayHelloTo("Nick");
	let first=function(arg1,arg2){
		console.log("First"+arg1);
		console.log("First"+arg2);
	}
	first("arg2","arg1");

	// return - вернуть из функции значение
	let double=function(Number){
		return Number*2;
	}
	double(3);

	// Короткая запись функции 
	function funName(Alex){
		console.log("Hello,"+Alex+"!");
	};
	funName("Alex");

	// Function Expression в сравнении с Function Declaration
	/*

		Давайте разберём ключевые отличия Function Declaration от Function Expression.
		Во-первых, синтаксис: как отличить их друг от друга в коде.
		Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.

		Function Declaration может быть вызвана раньше, чем она объявлена.
		Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, 
		прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».
		И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.
	
	*/
			// Function Declaration
			function sum(a, b) {
			return a + b;
			}
	/*
	
			Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции.
			В данном случае функция создаётся в правой части «выражения присваивания» =:

			Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
			После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, 
			функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).
	
	*/
			// Function Expression
			let sums = function(a, b) {
			return a + b;
			};

	
	// Стрелочные функции, основы

	/*
	
		Существует ещё один очень простой и лаконичный синтаксис для создания функций, который часто лучше, чем Function Expression.	
		Он называется «функции-стрелки» или «стрелочные функции» (arrow functions), т.к. выглядит следующим образом:

	*/
	
		let func = (arg1, arg2, ...argN) => expression;

	/*
	
		Это создаёт функцию func, которая принимает аргументы arg1..argN, затем вычисляет 
		expression в правой части с их использованием и возвращает результат.

	*/
		// Другими словами, это сокращённая версия:
		let func2 = function(arg1, arg2, ...argN) {
		return expression;
		};





// ЦИКЛЫ - предусмотрено для многократного выполнение одного-тогоже отрезка кода пока некое условие дает true

// While (простой цикл) - этот цикл снова и снова выполняет код своего тела, до тех пор пока заданное условие не дасть FALSE

// Синтаксис
let sheep=0;
while(sheep<5){
	console.log("Sanaldi:"+sheep);  // Тела цикла
	sheep ++;                        // Тут будет выполняться код
}
console.log("xrrrr-pxxx");
// Тела цикла будеть выполняется только когда условия будеть TRUE


// Do - такой способь нужно использовать когда нам необходимо хотябы одно выполнение тела цикла.
let sheeps=0;
do {
	console.log(sheeps);
	sheeps++;
} while(sheeps<4);

// For - упрощает создание циклов
	// 1) Начало - создает переменную
	// 2) Условия - дается условия
	// 3) Шаг(код) - указываем как должен изменит код
	// 4) Тела цикла - напишемм тела цикла

// Синтаксис
for(let shep=0; shep<3; shep++) {
	console.log("Sanaldi:"+shep);
};

//Работа цикла For 
	// 1) Выполняется начало - let shep=0
	// 2) Выполняется условия - shep<3
	// 3) Если устовия TRUE выполняется тела цикла - console.log("Sanaldi:"+ shep);
	// 4) Выполняется  шаг(код) - shep++


/*

	Прерывание цикла: «break»
	Обычно цикл завершается при вычислении условия в false.
	Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.

	Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, 
	а переходит к следующей итерации (если условие все ещё равно true).
	Её используют, если понятно, что на текущем повторе цикла делать больше нечего.
	Например, цикл ниже использует continue, чтобы выводить только нечётные значения:

*/
	for (let i = 0; i < 10; i++) {

		// если true, пропустить  часть тела цикла
		if (i % 2 == 0) continue;
	
		console.log(i); // 1, затем 3, 5, 7, 9
	}

// for..in -используется для перебора всех свойств объекта, массива. 
// Синтаксис
/*

		for (key in object) {
			тело цикла выполняется для каждого свойства объекта и массива
	 }

*/


	 let userFor = {
		name: "John",
		age: 30,
		isAdmin: true
	 };
	 
	 for (let key in user) {
		// ключи
		 console.log( key );  // name, age, isAdmin
		// значения ключей
		console.log( user[key] ); // John, 30, true
	 }





// УСЛОВНЫЙ ОПЕРАТОР If....Else
// Условная конструкция - если что-то истина (TRUE) сделай это, иначе сделай то.
// Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
//          ПРИМЕР: Выплонив дом.зад. можешь сьесть морожное, Если не готов, морожное не светить.

// Синтакси:
/*        if УСЛОВИЯ (ЧТО ХОТИМ ПРОВЕРИТЬ ){
			console.log()	ЧТО ХОТИМ ВЫПОЛНИТЬ
		}
*/

// IF - используется, чтобы запускать код, если некое условия только истинно (TRUE).
	let ifName="Niko";
	console.log("hello," + ifName);
	if(ifName.length > 5){
		console.log("You have a long name!!!");
	}

	let ifName1="Nikolas";
	console.log("hello," + ifName1);
	if(ifName1.length>5){
		console.log("You have a long name!!!");
	}

// Короткое запись:
	// If (ifName.length>5) console.log("You have a long name!!!");
	

// IF....ELSE - используетсяб чтобы запускать кодб если устовие дасть(TRUE) или (FALE).
	let ifName2="Niko";
		console.log("hello," + ifName2);
		if(ifName2.length>5){
			console.log("You have a long name!!!");
		} else{
			console.log("You do not have a long name");
		}

// Иногда, нужно проверить несколько вариантов условия. Для этого используется блок else if.
	if(1>50){
		console.log("5 большо 50");
	} else if(1>50){
		console.log("5 большо 30");
	} else if(1>50){
		console.log("5 большо 1");
	} else{
		console.log("Условие не выалнено");
	};


// Условный оператор (?) - позволяет нам сделать условия более коротким и простым способом.
// Синтаксис: 
	// let result = (uslovia) ? znawenia1 : znawenia2;
	let accessAllowed = (ifName > 18) ? true : false;

// Несколько операторов „?“
// Последовательность операторов вопросительного знака ? позволяет вернуть значение, которое зависит от более чем одного условия.


	let ages = ('Возраст?', 18);

	let message = (ages < 3) ? 'Здравствуй, малыш!' :
	(ages < 18) ? 'Привет!' :
	(ages < 100) ? 'Здравствуйте!' :
	'Какой необычный возраст!';
/*

	Поначалу может быть сложно понять, что происходит. Но при ближайшем рассмотрении
	мы видим, что это обычная последовательная проверка:

		1) Первый знак вопроса проверяет age < 3.
		2) Если верно – возвращает 'Здравствуй, малыш!'. В противном случае, 
	проверяет выражение после двоеточия „:“, вычисляет age < 18.
		3) Если это верно – возвращает 'Привет!'. В противном случае, проверяет 
	выражение после следующего двоеточия „:“, вычисляет age < 100.
		4) Если это верно – возвращает 'Здравствуйте!'. В противном случае, 
	возвращает выражение после последнего двоеточия – 'Какой необычный возраст!'.

*/



// DOM- представляет собой всю содержимое HTML страницы  виде объектов которое можно менять.
//      это средство позваляющее JS коду взаимодействовать с содержимым веб-страниц.

  	// НАВИГАЦИЯ ПО ДОКУМЕНТУ
	// document-самый верхние элементы дерева доступны как свойства объекта
	
	const htmlElement=document.documentElement; //html
	console.log(htmlElement);
	const headElement=document.head; //head
	console.log(headElement);
	const bodyElement=document.body; //body
	console.log(bodyElement);

	// Получаем первый и последний дочерние элементы
	const firstChildNote=bodyElement.firstChild;
	console.log(firstChildNote);
	const lastChildNote=bodyElement.lastChild;
	console.log(lastChildNote);



	//Узлый-отдельный узель между элементами
	// childNodes - получает список всех непостредственных детей объекта
	const childNodes=bodyElement.childNodes;
	console.log(childNodes);

	// hasChildNodes - использует для проверки наличия дочерних узлов.
	console.log(bodyElement.hasChildNodes());

	// Обращение к месту узла объекта
	// Преведующий узель объекта
	const previousSiblingNode=bodyElement.previousSibling;
	console.log(previousSiblingNode);

	// Следующий узель объекта
	const nextSiblingNode=bodyElement.nextSibling;
	console.log(nextSiblingNode);

	// Обращение к родителам объекта
	const parentNode=bodyElement.parentNode;
	console.log(parentNode);

	// children- получаем коллекцию всех дочерних элементов.
	const bodyChildren=bodyElement.children;
	console.log(bodyChildren);

	// Получаем первый и последний дочерние элементы
	const firstChild=bodyElement.firstElementChild;
	console.log(firstChild);
	const lastChild=bodyElement.lastElementChild;
	console.log(lastChild);

	// Обращение к месту элементу объекта
	// Преведующий элемент объекта
	const previousChildren=bodyElement.previousElementSibling;
	console.log(previousChildren);

	// Следующий элемент объекта
	const nextChildren=bodyElement.nextElementSibling;
	console.log(nextChildren);

	// Обращение к родителам объекта
	const parentElement=bodyElement.parentElement;
	console.log(parentElement);



	// Как получить праизвольный объект

	// querySelectorAll  
	// Пойск по селектору класса:
	const elemsOne=document.querySelectorAll(".data");
	console.log(elemsOne);

	// Пойск по селектору тега
	const elemsTwo=document.querySelectorAll("div");
	console.log(elemsTwo);

	// Пойск по селектору тега и класса
	const elemsThree=document.querySelectorAll("div.data__science");
	console.log(elemsThree);

	// Пойск по тегу первого уровня вложности
	const elemsFour=document.querySelectorAll(".data__science>li");
	console.log(elemsFour);
	
	//Пойск по нескольким классам 
	const elemsFive=document.querySelectorAll(".data, .data__science");
	console.log(elemsFive);

	// Пойск по вложенным классам
	const elemsSix=document.querySelectorAll(".data__science .data__list");
	console.log(elemsSix);

	// Пойск по ID
	const elemsSeven=document.querySelectorAll("#ideation");
	console.log(elemsSeven);

	// Пойск по атрибуту
	const elemsEight=document.querySelectorAll("[data-item]");
	console.log(elemsEight);

	// Пойск по атрибуту со значением
	const elemsNine=document.querySelectorAll('[data-item="85"]');
	console.log(elemsNine);

	// Получение конкретного элемента коллекции
	const elemsTen=document.querySelectorAll("li");
	console.log(elemsTen[3]);

	// Пойск только одного элемента
	const elemsEleven=document.querySelector(".data__text");
	console.log(elemsEleven);

	// getElementById
	// Пойск по ID
	const getOne=document.getElementById("ideation");
	console.log(getOne);

	// Ищет элеметы с данными тега и возвращает их коллекцию
	const getTwo=document.getElementsByTagName("div");
	console.log(getTwo);

	// Возвращает элементы которыу имеет данние СSS классов
	const getThree=document.getElementsByClassName(".data__text");
	console.log(getThree);
	
	// Возвращает элементы с заданным атрибутам name 
	const getFour=document.getElementsByName("adilet");
	console.log(getFour);

	// Живые и неживые коллекции в JavaScript
	// Найти несколько DOM-элементов и получить к ним доступ из JavaScript можно разными способами: querySelectorAll, getElementsByTagName, children и так далее. В итоге в каждом случае будет возвращена коллекция — сущность, которая похожа на массив объектов, но при этом им не является, на самом деле это набор DOM-элементов. Стоит учесть, что фактически разные методы возвращают разные коллекции:
	
		// HTMLCollection — коллекция непосредственно HTML-элементов.
		// NodeList — коллекция узлов, более абстрактное понятие. Например, в DOM-дереве есть не только узлы-элементы, но также текстовые узлы, узлы-комментарии и другие, поэтому NodeList может содержать другие типы узлов.

		// Во время работы с коллекциями можно столкнуться с поведением, которое покажется странным, если не знать один нюанс — они бывают живыми (динамическими) и неживыми (статическими). То есть либо реагируют на любое изменение DOM, либо нет. Вид коллекции зависит от способа, с помощью которого она получена. Рассмотрим на примере.

		const booksList = document.querySelector('.books');
		const liveBooks = booksList.children;

		// Выведем все дочерние элементы списка .books
		console.log(liveBooks);
		// Удалим первую книгу
		liveBooks[0].remove();
		// Получим 2
		console.log(liveBooks.length);
		// Получим элемент book--two, который теперь стал первым в коллекции
		console.log(liveBooks[0]);

		const notLiveBooks = document.querySelectorAll('.book');

		// Выведем коллекцию, содержащую все элементы с классом book
		console.log(notLiveBooks);
		// Удалим первую книгу
		notLiveBooks[0].remove();
		// Получим 3
		console.log(notLiveBooks.length);
		// Получим ссылку на удалённый элемент book--one
		console.log(notLiveBooks[0]);

	// В первом случае информация о количестве элементов внутри коллекции автоматически обновилась после удаления одного элемента из DOM — эта коллекция живая. Во втором случае в переменной notLiveBooks хранится первоначальное состояние коллекции, которое было актуально на момент вызова метода querySelectorAll. Эта коллекция неживая, она ничего не знает об изменении DOM. При этом доступна ссылка на удалённый элемент book--one, которого фактически больше нет в DOM.

	// Другие способы получить коллекцию
	// Кроме children и querySelectorAll есть другие способы поиска DOM-элементов:
	// 	getElementsByTagName(tag) — находит все элементы с заданным тегом,	
	// 	getElementsByClassName(className) — находит все элементы с заданным классом,
	// 	getElementsByName(name) — находит все элементы с заданным атрибутом name.

	// ИЗМЕНЕНИЕ DOM
	// innerHTML
	// Получаем содержимое объета кк есть без тегов
	const textElement=document.querySelector(".inner__text");
	const textElementContent=textElement.innerHTML;
	console.log(textElementContent);
	textElement.innerHTML="Живи а работай в свободное время!";

	// outerHTML
	// Выберает сам элемент циликом вместе в тегами
	const textElem=document.querySelector(".inner__title");
	const textElemCont=textElem.outerHTML;
	console.log(textElemCont);
	textElem.outerHTML="lorem ipsum si amet has lot of time!";
	console.log(textElem.outerHTML);

	// textContent
	// выводит только текст без тегов, если выводит или изменит контент или доб тегов, то он превращается в текст.
	const textEl=document.querySelector(".inner__span");
	const textElCon=textEl.textContent;
	console.log(textElCon);
	textEl.textContent="<p>Живи а работай в свободное время!</p>";
	console.log(textEl.textContent);

	// createElement
	// Создание элементов и узлов
	const newElement=document.createElement("div");
	console.log(newElement);
	// Наполняем новый элемент
	newElement.innerHTML="lorem ipsum great head to learn English language";
	console.log(newElement);

	// Создание нового текстового узла
	const newText=document.createTextNode("Hello");
	console.log(newText);


	// Метод вставки
	// 1) Получаем объект
	const textMethod=document.querySelector(".inner__method")
	// 2) Создание нового элемента
	const newMethod=document.createElement("div")
	// 3) Наполняем новый элемент
	newMethod.innerHTML="Ainadinov Adilet Akimzhanuli";
	// 4) Вставляем новый элемент
	textMethod.before(newMethod); //Перед объектом
	textMethod.after(newMethod); //После объекта
	textMethod.prepend(newMethod);//Внутрь и в начале объекта
	textMethod.append(newMethod);//Внутрь и в конец объекта

	
	// insertAdjacentHTML вставка или изменение адреса готового элемента
	// 1) Получаем объект
	const insElement=document.querySelector(".inner");
	// 2) Вставляем текст, html, элемент
	insElement.insertAdjacentHTML(
		'beforebegin', 								//Перед объектом
		'<p>Lorem ipsum tex align center</p>'
	);
	insElement.insertAdjacentHTML(
		'afterbegin',									//Внутрь и в начале объекта
		'<p>Lorem ipsum tex align center</p>'
	);
	insElement.insertAdjacentHTML(
		'afterend', 									//После объекта
		'<p>Lorem ipsum tex align center</p>'
	);
	insElement.insertAdjacentHTML(
		'beforeend',									//Внутрь и в конец объекта
		'<p>Lorem ipsum tex align center</p>'
	);


	// Перенос элемента - мы можем вставлять не только новые узлы, но и переносить существующие
	// 1) Получаем объект
	const lessonBlock=document.querySelector(".inner");
	// 2) Переносим h1 в inner
	const title=document.querySelector("h1");
	lessonBlock.append(title); //Внутрь и в конец объекта
	lessonBlock.after(title); //После объекта
	lessonBlock.before(title);  //Перед объектом
	lessonBlock.prepend(title); //Внутрь и в начале объекта

	//CloneNode - клонирование узлов
	// 1) Получаем объект
	const cloElement=document.querySelector(".inner");
	// 2) Клонироваем
	// const cloneTextElement = cloElement.cloneNode(); Поверхности
	const cloneTextElement = cloElement.cloneNode(true); // Глубокий
	// 3) Вставляем клонированный элемент
	const cloneBlock=document.querySelector(".data");
	cloneBlock.prepend(cloneTextElement);

	// Удаление узлов
	// 1) Получаем объект
	const cloneAdd=document.querySelector(".del__node");
	// 2) Удаляем объект
	cloneAdd.remove();




// СТИЛИ И КЛАССЫ
// Управление классами
	// className
		// 1) Получаем объект
		const classN=document.querySelector(".inner__method");
		// 2) Получаем имена классов
		const className=classN.className;
		console.log(className);
		// 3) Перезаписиваем имя класса
		classN.className = "red";


	// classList - спец объект с методами для добавления или удаления одного класса
		// 1) Получаем объект
		const classElem=document.querySelector(".inner__method");
		// 2) Изменение классов
			classElem.classList.add("inner", "item") // добавление класса
			classElem.classList.remove("inner") // удаление класса 
			classElem.classList.toggle("wrap") // добавляет класс если его нет, а если есть удалить
			classElem.classList.contains("wrap") // проверка наличие класса
	

// Управление стилми 
	// .style 
		// 1) Получаем объект
		const classCss=document.querySelector(".inner__method");
		// 2) Задаем стиль с помощью CSS свойств 
		classCss.style.color = "red"
		// Сброс стиля
		classCss.style.color = "";
		// style.cssText - полный перезапиь стилей
		classCss.style.cssText = `
			color: blue;
			margin-bottom: 30px;
		`;



// РАЗМЕРЫ ОКНА БРАУЗЕРА
// clientWidth  и clientHeight

// Доступная шрина и высота окна
const mainElement = document.documentElement;
const mainElementWidth = mainElement.clientHeight; 
const mainElementHeight = mainElement.clientWidth;

console.log(mainElementHeight);
console.log(mainElementWidth);


// Ширина и высота окна вместе с полосамии прокрутки
const windowWidth = window.innerWidth; 
const windowHeight = window.innerHeight; 

console.log(windowHeight);
console.log(windowWidth);


// Получить кол-во прокрученных пикселей
// Только для чтения
const windowScrollTop = window.pageYOffset;
const windowScrollLeft = window.pageXOffset;

console.log(windowScrollTop);
console.log(windowScrollLeft);


// УПРАВЛЕНИЯ ПРОКРУТКОЙ СТРАНИЦЫ
// МЕТОД scrollBy(x,y) прокруыивает страницу относительно её текущего положения
// каждый раз доб-ть текущему скролу (пикселей)
function setScrollBy() {
	window.scrollBy(0, 50);
	const windowScrollTop = window.pageYOffset;
	console.log(windowScrollTop)	
}

// scrollTo(pageX, pageY,) прокручивает страницу на абсолютные кординаты
// доб-ть только один раз текущему скролу (пикселей)
function setScrollTo() {
	window.scrollTo(0, 50);
	const windowScrollTop = window.pageYOffset;
	console.log(windowScrollTop)	
}

// опций не работает в Safari
function setScrollToOptions(){
	windowScrollLeft.scrollTo({
		top:500,
		left:0,
		// smooth, instant,
		// по умолчания auto
		behavior: "smooth"
	});
}


// МЕТОД scrollIntoView(top) прокручивает страницу, чтобы элемент оказался вверху. У него есть один аргумент
/*
	-если top = true(по умолчанию), то страница будет прокручена, чтобы элемент появилься в верхной части окна.
	 верхний край элемента совмещен с верхней частью окна.
	
	-если top = false, то страница будет прокручена, чтобы элемент появился внизу.
	 нижний край элемента будет совмещён с нижним краем окна.

*/

	function setScrollIntoView(top){
		const lessonSelected = document.querySelector(".inner__span");
		lessonSelected.scrollIntoView(top);

	}

	// опций не работает в Safari
	function setScrollIntoViewOptions(top){
		const lessonSelected = document.querySelector('.inner__span');
		lessonSelected.scrollIntoView({
			// "start", "center", "end" или "nearest" вертикальная прокрутка
			block: "center",
			// "start", "center", "end" или "nearest" горизантальная прокрутка
			inline: "nearest",
			//  "autp", "smooth" плавность скролла
			behavior: "smooth"
		})
	}


// Запретить прокрутку
function setEnableDisableScroll(){
	document.body.style.overflow = "hidden";
	// или
	document.body.classList.toggle('scroll-lock');
}



//СОБЫТИЕ В JAVASCRIPT
// Событие - это сигнал поступающие в браузер о том 
// что-то произошло (клик мышью, прокрутка скролла, нажатие клавиш, загрузка страниц)

/*
	Отлавливат возникновение события мы будем с помощью 
	специальных обработчиков

	Любому событи можно назначит обработчиков, то есть функцию, которое сработает, 
	как только произоидет нужное нам событие.


	Есть несколько  способов назначить событие обработчик
*/

// 1. Использивание атрибута HTML
//   <button type="button" class="dev__click" onclick="console.log('Click')">Click</button>

// 2. Использивание DOM - обьекта
  const button = document.querySelector(".dev__click--two");

  button.onclick = function(){
	console.log('Click');
  }

  function clickTwo(){
	console.log('Click');
  }
  button.onclick = clickTwo;


// Обработчик событий addEventListner, removeEventsListner
// Синтаксис 
// element.addEventListner(события, функция [параметры])

//   Вызов двоиной событий
	const buttonThree = document.querySelector(".dev__click--three");
	buttonThree.addEventListener("click", function(e) {
		console.log('Click')
	});
	buttonThree.addEventListener("click", function(e) {
		console.log('Clack')
	});

//  Отключение событий  - removeEventsListner

	const buttonFour = document.querySelector(".dev__click--four");

	function clickFour(){
		console.log('Click');
		buttonFour.removeEventListener("click", clickFour);
	}
	buttonFour.addEventListener("click", clickFour);

/*
	 Метод addEventListner  может показаться сложнее чем, onclick 
	но из-за того что он обладает преимуществом выполнение нескольких событий 
	и можно отложить события только при помощи этого метода.
	В результате разработчики чаще использует именно его.

*/ 

// Опции (параметры)
	const options = {
		"capture" : false, // фаза, на которой сработать обработчик
		"once" : true, // если true, тогда обработчик будет автоматический удалён после выполнения
		"passive" : false // если true, то указывает, что обработчик никогда не вызовет preventDefault()
	}
	const buttonFive = document.querySelector(".dev__click--five");

	function clickFive(){
		console.log('Click');
	}
	buttonFive.addEventListener("click", clickFive,  options);



// Объект события
/*
	чтобы хорошо обработать событие, могут понодобиться детали того, что произошло
	не просто (клик и клак или нажатия клавишии) 
	а также какие координаты указателя мыши, какя клавиша нажата и так далее
	когда происходит событие, браузер создаёт обьект события, записывает в него детали
	и передает его в качестве аргумента функции - обработчику.
*/
// Тип события
const eventOne = document.querySelector(".event__click--one");
function oneEvent(event){
	console.log(event.type);
}
eventOne.addEventListener("click", oneEvent);

// Объект на котором сработал обработчик
const eventTwo = document.querySelector(".event__click--two");
function twoEvent(event){
	console.log(event.target);
}
eventTwo.addEventListener("click", twoEvent);

// Объект на которому назначен обработчик 
const eventThree = document.querySelector(".event__click--three");
function threeEvent(event){
	console.log(event.currentTarget);
}
eventThree.addEventListener("click", threeEvent);

// Положение курсоров по оси Х и У
const eventFour = document.querySelector(".event__click--four");
function fourEvent(event){
	console.log(event.clientX);
	console.log(event.clientY);
}
eventFour.addEventListener("click", fourEvent);




// Всплытие и погружение
 const block = document.querySelector(".block")
 const blockSecond = document.querySelector(".block__second")
 const blockThird = document.querySelector(".block__third")

/*

Всплытие - это когда на элементе происходит событие, 
обработчики сначала срабативает на нём, потом на его родителя, 
затем выше и так далее, вверх по цепочке предков.


Погружение - для того чтобы что-то всплыло, оно должно сначала погрузиться 
отсловит событие погружение с помошью options
{ "capture": true}
*/

block.addEventListener("click", function(event){
	console.log("Click on 1 block")
});
blockSecond.addEventListener("click", function(event){
	console.log("Click on 2 block")
},);
blockThird.addEventListener("click", function(event){
	console.log("Click on 30 block")
	// event.stopPropagation(); - остановка всплытие 
});



// Делегирование событий

/*

 Всплитие и погружение событий позваляет реагировать
один из самых важных разработки - делегирование.

 Идея в том, что если у нас есть много элементов, события на которых нужно 
обрабатывать похожим образом, то вместо того, чтобы назначать обработчик 
каждому, мы ставим один обработчик на их общего предка.
 Из него можно получить целевой элемент event.target, понять на каком именно 
потомке произошло событие и обработать его.

*/

const deleg = document.querySelectorAll(".dev__del")

function showDel(){
	console.log('Ura!!');
}
deleg.forEach(delehItem => {
	delehItem.addEventListener("click", showDel);
});

// Делегирование событие на родителя

const devdel = document.querySelector(".delev")
function showDevdel(){
	console.log('Ura');
}
devdel.addEventListener("click", function(event){
	if (event.target.closest('.dev__delev')){
		showDel();
	}
})


// Действия браузера по умолчания
/*
	Многие события автоматически влекут за собой дейтсвие браузер
	Например:
	- клик по сылке иницирует переход на новый URL
	- нажатие на кнопку (отправить) в форме - отсылку её на сервер
	- зажатие кнопки мыши над текстом и её движение

	Если мы обрабатываем событие и JavaScript
	то зачастую такое действие браузера нам не нужно.
	К счастью, его можно отменить.
*/

	const desLink = document.querySelector(".google__link")
	
	desLink.addEventListener("click", function(event){
		console.log('our action');
		// отменить действие браузера (переход по ссылке)
		event.preventDefault();
	})




// Основы событий мыщи
/*
	Типы событий мыши:
		1. Простые события - самые часто используемые события
			mousedown - кнопка мыши нажата
			mouseup - отпущена над элементом
			mouseover - курсор мыши появляется над элементом 
			mouseout - курсор мыши уходит над элементом
			mousemove - каждое движение мыши над элементом генерирует это событие
			contextmenu - вызывается при попытке открытия контекстного меню,
							  оно может вызываться и специальной клавишей клавиатуры. 

		2. Комплексные события 
			click - вызывается при mousedown, а затем mouseup над одним
			 		  и тем же элементом, если исрользовалось основная кнопка мыши.
			dbclick - вызывается двойным кликом на элементе.
						 
*/


const mouse = document.querySelector(".mouse__click")

// 1. mousedown 
/*
	event.which = 1 -нажата основная кнопка мыши(левая)
	event.which = 2 -нажата средняя кнопка мыши(колесо)
	event.which = 3 -нажата не основная кнопка мыши(правая)
*/
	mouse.addEventListener("mousedown", function(event){
		console.log(`click buttom  ${event.which}`);
	});

// 2. mouseup
	mouse.addEventListener("mouseup", function(event){
		console.log('click buttom basic');
	});

// 3. contextmenu
	mouse.addEventListener("contextmenu", function(event){
		console.log('click buttom context menu');
	});

// 4. mousemove 
	const mouseMove = document.querySelector(".mouse__move")
	mouseMove.addEventListener("mousemove", function(event){
		mouseMove.innerHTML = 
		`clientX -${event.clientX} <br> clientY -${event.clientY}`;
	})

// 5-6. mouseover|mouseout
	const mouseOvOut = document.querySelector(".mouse__ovout");
	mouseOvOut.addEventListener("mouseover", function(event){
		mouseOvOut.innerHTML = `cursor on the element`
	});
	mouseOvOut.addEventListener("mouseout", function(event){
		mouseOvOut.innerHTML = `cursor go out the element`
	});

	// relatedTarget - когда мышь переходит с одного элемента на другой, 
	// то один из них будет Target, а другой relatedTarget.
	/*
	 
		Для события mouseover:
		event.target - это элемент, на который курсор перешёл.
		event.relatedTarget - это элемент, с которого курсор ушёл.

		Для события mouseout:
		event.target - это элемент, с которого курсор ушёл
		event.relatedTarget - .это элемент, на который курсор перешёл.

	 */

		const mouseRel = document.querySelector(".mouse__rel");
		mouseRel.addEventListener("mouseover", function(event){
			console.log(event.target);
			console.log(event.relatedTarget);
		});
		mouseRel.addEventListener("mouseout", function(event){
			console.log(event.target);
			console.log(event.relatedTarget);
		});

// 7-8. mouseenter|mouseleave
	/*
	
		Пара важных отличий:
		1. Переходы внутри элемента, на его потомки и с них, не считается.(событие не происходит)
		2. События mouseenter|mouseleave не всплывает.(событие происходит только определенном элементе) 
	
	*/
	const mouseenleav = document.querySelector(".mouse__enleav");
	mouseenleav.addEventListener("mouseenter", function(event){
		console.log(`Курсор над элементом`);
	});
	mouseenleav.addEventListener("mouseleave", function(event){
		console.log(`Курсор уходит с элемента`);
	});




// Клавиатура

/*

	Основные события при работе с клавиатурой это:
		keydown	- происходит при нажати клавиши
		keyup	- при отпускании клавиши

*/

// event.code u event.key
/*

	event.code - отрабажается какая кнопка нажата только на англиском языке.
	event.key - отрабажается какая кнопка нажата верхном\нижном регисторе, на разных языках. 

*/

	document.addEventListener("keydown", function (event) {
		console.log(`Нажата клавиша ${event.code} (${event.key})`);
	});	
	document.addEventListener("keydup", function (event) {
		console.log(`Отжата клавиша ${event.code} (${event.key})`);
	});	

/*

	Автоповтор - при долгом нажатии клавиши возникает автоповтор: keydown срабатывает
	снова и снова, и когда клавишу отпускают, то отрабатывает keyup.
	Для событий, вызванных автоповтором, у объекта события свойство event.pereat равно true

*/ 
	document.addEventListener("keydown", function (event) {
		console.log(`Нажата клавиша ${event.code} (${event.key})`);
		console.log(event.repeat);
	});


// Прокрутка (скролл)

/*

	Использование:
	- Показать / скрыть доп-ы элементы управления или информацию, 
	основываяcь на том, в какой части документа находится пользователь.
	- Подзогрузить данные, когда пользователь прокручивает страницу вниз
	до конца. Безконечный скролл
*/

	window.addEventListener('scroll', function(event){
		// console.log(`${scrollY}px`) - кол-во прокрученных пикселей по вертикали 
		// console.log(`${scrollX}px`) - кол-во прокрученных пикселей по горизонтали
	})

/*

	Нельзя предотвратить, используя event.preventDefault() в обработчике scroll,
	но можно предотвратит прокрутку, используя, например на сабытии keydown для 
	клавиш pageUp u pageDown.

	Способов инициировать прокрутку много, более надёжный способ - использовать 
	CSS, свойство overflow: hidden;

*/


// События загрузки страницы 

/*

	1) DOMContentLoaded - браузер полностью загрузил HTML, было построено DOM, 
		но внешные ресурсы, такие как картинки и стили, могут быть ещё не загружены.
	2) load - браузер загрузил HTML и внешние ресурсы(картинки, стили и т.д)
	3) beforeunload | unload - пользователь покидает страницу

*/

// Событие DOMContentLoaded срабатывает на объекте document
	document.addEventListener("DOMContentLoaded", readyDom);
	function readyDom(){
		const image = document.querySelector('.image')
		console.log(document.readyState);
		console.log('DOM loaded');
		console.log(image.offsetWidth);
	}

//  Событие load срабатывает на объекте window
	window.addEventListener("load", readyLoad);
	function readyLoad(){
	const image = document.querySelector('.image')
	console.log(document.readyState);
	console.log('Page loaded');
	console.log(image.offsetWidth);
	}

/*

	document.readyState - состояние загрузки

	Есть три возможных значения:
	"loading" - документ загружается.
	"interactive" - документ был полностью прочитон.
	"complete" - документ был польностью прочитон или все ресурсы были тоже загружены.


*/



// Свойства и методы форм

// document.forms - коллекция всех форм на странице

	console.log(document.forms); // Получить коллекцию всех форм на странице
	
	const mainForm = document.forms[0]; // Получить конкретную форму на странице
	console.log(mainForm);

	const mainForm1 = document.forms.main; // Атрибут name
	console.log(mainForm1);
	console.log(mainForm1.elements); // Для получения всех элементов форм обьекта
	const mainForm2 = document.forms.main.elements.mainInput; // Для получения конкретного элемента форм обьекта
	console.log(mainForm2);


	
// Работа с input и textarea
/*

	Значение можно получить через свойство input.value(строка)
	или input.checked(булево значение) для чекбоксов и радиокнопок.

*/
	const mainForm3 = document.forms.main;

	const mainFormInput = mainForm3.mainInput;
	const mainFormTextarea = mainForm3.mainTextarea;

// Получить значение (содержимое) поля 
	console.log(mainFormInput.value);
// Получить значение (содержимое) текстового поля 
	console.log(mainFormTextarea.value);

// Присвоить значение (содержимое) поля
	mainFormInput.value = "Bye"
// Присвоить значение (содержимое) текстового поля
	mainFormTextarea.value = "Good Bye"



// Работа с radio и checkbox

	const mainFormRadio = mainForm3.mainRadio
	const mainFormCheckbox = mainForm3.mainCheck
	const mainFormFile = mainForm3.mainFile

// Получить значение поля type radio
	console.log(mainFormRadio[0].value);
	console.log(mainFormRadio[1].value);
	console.log(mainFormRadio[0].checked);
	console.log(mainFormRadio[1].checked);

// Назначить(изменить) значение поля type radio
  	mainFormRadio[0].value = "left";
	mainFormRadio[1].value = "right";
	mainFormRadio[1].checked = true;

// Получить значение поля type checkbox
	console.log(mainFormCheckbox.value);
	console.log(mainFormCheckbox.checked);

// Назначить(изменить)значение поля type checkbox
	mainFormCheckbox.value = "save";
	mainFormCheckbox.checked = true;

// Получить значение поля type file
	console.log(mainFormFile.value);


// Работа с select u option
/*

	Элемент <select> имеет 3 важных свойств:
		select.options - коллекция из подэлемента <option>
		select.value - значение выбронного в данный момент <option>
		select.selectedIndex - номер выбранного <option>

*/
	const mainForm4 = document.forms.main;
	const mainFormSelect = mainForm4.nameSelect;

	// Получить все options
	console.log(mainForm4.nameSelect.options);
	// Получить индекс выбронного options
	const mainFormSelectIndex = mainFormSelect.selectedIndex;
	console.log(mainFormSelectIndex);
	// Получить значение(атрибута) выбронного options
	const mainFormSelectValue = mainFormSelect.value;
	console.log(mainFormSelectValue);
	// Получить текст выбронного options
	const mainFormSelectText = mainFormSelect.options[mainFormSelectIndex].text;
	console.log(mainFormSelectText);

/*

	Элементы  <option> имеет свойств:
	option.selected - выбрана ли опция.
	option.index - номер опции среди другиз в списке <select>
	option.text - содержимое опции (то, что видит посетитель)

*/
	
// Добавить новую опцию 
/*

	new Option(text, value, defaultSelected, selected);
	Параметры:
	text - текст внутри <option>
	value - значение,
	defaultSelected - если true, то ставится HTML - атрибуть selected. 
	selected - если true, то элемент <option> будет выбранным.

*/ 
	let newOption = new Option("100", "4", false, true);
	mainFormSelect.append(newOption);



// События focus u blur
/*

	Focus - когда пользователь кликает по нему 
			  или использует клавишу Tab.
	Blur - момент потери фокуса.

*/

	const mainForm5 = document.forms.main;
	const mainFormInput2 = mainForm5.mainInput2;

	const mainFormInput2Placeholder = mainFormInput2.placeholder;

	mainFormInput2.addEventListener("focus", function(e){
		mainFormInput2.placeholder = "";
	});
	mainFormInput2.addEventListener("blur", function(e){
		mainFormInput2.placeholder = mainFormInput2Placeholder;
	});

// Событие change - срабатывает по окончании изменения элемнта
/*

	В текстовых input u textarea срабатывает в моменте потерия фокуса,
	но в radio, select, checkbox и т.д сразу

*/
	mainFormInput2.addEventListener("change", function(e){
		console.log('event change');
	});
	

// События input 

/*

	Событие input срабатывает каждый раз при изменении значения.

*/
	mainFormInput2.addEventListener("input", function(e){
		console.log(`value: ${mainFormInput2.value}`);
	});

// Событие cut, copy, paste
/*

	Эти событие происходит при вырезании, копировании, вставке данных.

*/

mainFormInput2.addEventListener("cut", function(e){
	console.log("вырезанем");
});
mainFormInput2.addEventListener("copy", function(e){
	console.log("копируем");
});
mainFormInput2.addEventListener("paste", function(e){
	console.log("вставляем");
});


// ПЛАНИРОВАНИЕ: setTimeout и setInterval

/*
	Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

*/

// setTimeout - позволяет вызвать функцию один раз через определённый интервал времени.

// let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);

// func|code - Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
// delay - Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
// arg1, arg2 - Аргументы, передаваемые в функцию 

	function sayHi1(phrase, who) {
		console.log( phrase + ', ' + who );
	}
	
	setTimeout(sayHi1, 1000, "Привет", "Джон"); // Привет, Джон
	setTimeout(() => console.log('Привет'), 1000);

// Отмена через clearTimeout
// Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.
// В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:
	
	let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
	alert(timerId); // идентификатор таймера
	
	clearTimeout(timerId);


// setInterval - позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
// Метод setInterval имеет такой же синтаксис как setTimeout:

// let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
// Все аргументы имеют такое же значение. Но отличие этого метода от setTimeout в том, что функция запускается не один раз, а периодически через указанный интервал времени.

// Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId).

// Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:

// повторить с интервалом 2 секунды
let timerId2 = setInterval(() => console.log('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId2); console.log('stop'); }, 5000);



// Callback - это функция которое передано в качестве аргумента в другой функций
	function learn(lesson, callback){
		setTimeout(()=>{
			console.log(`Сегодня мы проходим ${lesson} урок`)
			callback();
		},1000)
	}

	function init(callback){
		console.log('И мне это нравится!')
	}

	learn(7, init);


// ФЛАГИ И ДЕСКРИПТОРЫ СВОЙСТВ
	// Как мы знаем, объекты могут содержать свойства. До этого момента мы рассматривали свойство только как пару «ключ-значение». Но на самом деле свойство объекта гораздо мощнее и гибче.

	// Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги») обычно они скрыты. Когда мы создаём свойство «обычным способом», все они имеют значение true. Но мы можем изменить их в любое время.

		// writable – если true, свойство можно изменить, иначе оно только для чтения. никто не сможет изменить имя пользователя, если только не обновит соответствующий флаг новым вызовом defineProperty.

		// enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.

		// configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

	// Метод Object.getOwnPropertyDescriptor позволяет получить полную информацию о свойстве.
		// let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
		// obj - Объект, из которого мы получаем информацию.
		// propertyName - Имя свойства.

	// Чтобы изменить флаги, мы можем использовать метод Object.defineProperty.

		// Object.defineProperty(obj, propertyName, descriptor)
		// obj, propertyName - Объект и его свойство, для которого нужно применить дескриптор.
		// descriptor - Применяемый дескриптор.
		// Если свойство существует, defineProperty обновит его флаги. В противном случае метод создаёт новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение false.

	// Например, здесь создаётся свойство name, все флаги которого имеют значение false:

	let userDes = {};

		Object.defineProperty(userDes, "name", {
			value: "John"
		});



// Promise (промис) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции.
	
/*

	1) Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети.
	2) Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. 
	3) Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.

*/
	let promise1 = new Promise(function(resolve, reject) {
		// функция-исполнитель (executor)
		
	});

/*

	Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.
	Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
	resolve(value) — если работа завершилась успешно, с результатом value.
	reject(error) — если произошла ошибка, error – объект ошибки.

*/

	let promise2 = new Promise(function(resolve, reject) {
		// эта функция выполнится автоматически, при вызове new Promise
	
		// через 1 секунду сигнализировать, что задача выполнена с результатом "done"
		setTimeout(() => resolve("done"), 1000);

		 // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
		//  setTimeout(() => reject(new Error("Whoops!")), 1000);
	});


// Потребители: then, catch
// Объект Promise служит связующим звеном между исполнителем («создающим» кодом ) и функциями-потребителями , которые получат либо результат, либо ошибку. 	
// Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.

	// .then
	// Синтаксис:

	promise2.then(function(){
		console.log("done");
	})

	//аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

	// .catch
	// Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое:

	let promise3 = new Promise((resolve, reject) => {
		setTimeout(() => reject(new Error("Ошибка!")), 1000);
	  });
	  
	  // .catch(f) это то же самое, что promise.then(null, f)
	promise3.catch(function(){
		console.log(new Error);
	}); // выведет "Error: Ошибка!" спустя одну секунду


// API - некоторое готовое решение кода, можем использовать его методы, данные, свойсвта.
// 		DOM api, Promise api, Googles api, 2Gis api


// JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости.
// Например, мы можем использовать сетевой запрос, чтобы:

/*
	Отправить заказ,
	Загрузить информацию о пользователе,
	Запросить последние обновления с сервера,

*/

// Для сетевых запросов из JavaScript есть широко известный термин «AJAX» (аббревиатура от Asynchronous JavaScript And XML). XML мы использовать не обязаны, просто термин старый, поэтому в нём есть это слово. Возможно, вы его уже где-то слышали.

// Метод fetch() — современный и очень мощный, поэтому начнём с него. Он не поддерживается старыми (можно использовать полифил), но поддерживается всеми современными браузерами.

let promiseFetch = fetch('https://jsonplaceholder.typicode.com/todos')
				.then(response => response.json())
				.then(data => data.splice(0,10))

// url – URL для отправки запроса.
// options – дополнительные параметры: метод, заголовки и так далее.
// Без options это простой GET-запрос, скачивающий содержимое по адресу url.

// Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата. Процесс получения ответа обычно происходит в два этапа.
/*
	.then(response => response.json())
	
	1) promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.
	   На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.
	   Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.
	
	2) для получения тела ответа нам нужно использовать дополнительный вызов метода.
	   Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:
		response.text() – читает ответ и возвращает как обычный текст,
		response.json() – декодирует ответ в формате JSON,
		response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
		response.blob() – возвращает объект как Blob (бинарные данные с типом),
		response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),

	.then(data => data.splice(0,10))
		изпользоваем эти данный, объекты для работы
		
*/	
	fetch('https://jsonplaceholder.typicode.com/todos')
		.then(response => response.json())
		.then(data => data.splice(0,10))/*.forEach(item=>{
			tasks.innerHTML += `
			<div class="task">
				<span id="taskname">
					${item.title}
				</span>
				<button class="delete">
					<i class="far fa-trash-alt"></i>
				</button>
			</div>
		`;})*/

// POST-запросы - добавлаем данные, обекты в сервер
// Для отправки POST-запроса или запроса с другим методом, нам необходимо использовать fetch параметры:
/*
	method – HTTP метод, например POST,
	body – тело запроса, одно из списка:
	строка (например, в формате JSON),
	объект FormData для отправки данных как form/multipart,
	Blob/BufferSource для отправки бинарных данных,

*/
	const bodyFitch = { title: "NewFitch", completed: false, userId:1, id:201,}
	fetch('https://jsonplaceholder.typicode.com/todos', {
	method: 'POST',
	body: JSON.stringify(bodyFitch),
	headers: {
		'Content-type': 'application/json'
	}
	})
	.then((response)=>{
	console.log(response)
	return response.json()
	})
	.then(data=>console.log(data))
		

// Рекурсия –  в процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает сама себя.
// https://learn.javascript.ru/recursion

function pow(x, n) {
	if (n == 1) {
	  return x;
	} else {
	  return x * pow(x, n - 1);
	}
  }
  
console.log(pow(2, 4)); // 16

/*
  1. Если n == 1, тогда всё просто. Эта ветвь называется базой рекурсии, потому что сразу же приводит к очевидному результату: pow(x, 1) равно x.

  2. Мы можем представить pow(x, n) в виде: x * pow(x, n - 1). Что в математике записывается как: xn = x * xn-1. Эта ветвь – шаг рекурсии: мы сводим задачу к более 	простому действию (умножение на x) и более простой аналогичной задаче (pow с меньшим n). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает 1.
	
  Говорят, что функция pow рекурсивно вызывает саму себя до n == 1.

  Например, рекурсивный вариант вычисления pow(2, 4) состоит из шагов:

	1. pow(2, 4) = 2 * pow(2, 3)
	2. pow(2, 3) = 2 * pow(2, 2)
	3. pow(2, 2) = 2 * pow(2, 1)
	4. pow(2, 1) = 2
*/


// Операторы Spread и Rest

// Spread оператор (оператор расширения) 'берет' каждый отдельный элемент итерируемого объекта (массив) и 'распаковывает' его в другой итерируемый объект (массив).
	// К итерируемым объектам можно отнести все, что можно перебрать с помощью цикла for..of. Большая часть задач, где приходится использовать оператор spread, касается массивов и строк.
	const tvSeriesOne = ['Ozark', 'Fargo', 'Dexter'];
	const tvSeriesTwo = ['Mr. Robot', 'Barry', 'Suits'];
	const tvSeries = [...tvSeriesOne, ...tvSeriesTwo];
	console.log(tvSeries); // [ "Ozark", "Fargo", "Dexter", "Mr. Robot", "Barry", "Suits" ]

	const tvSeriesOne2 = ['Ozark', 'Fargo', 'Dexter'];
	const tvSeriesTwo2 = ['Mr. Robot', 'Barry', 'Suits'];
	const tvSeries2 = [...tvSeriesOne2, 'Sherlock', ...tvSeriesTwo2];
	console.log(tvSeries2);
	// [ "Ozark", "Fargo", "Dexter", "Sherlock", "Mr. Robot", "Barry", "Suits" ]

// Rest оператор  … (три точки) похож на оператор spread, но выполняет противоположную функцию.
	// Spread забирает каждый элемент из массива и распаковывает в новый массив. Оператор rest забирает каждый элемент из массива и создает из них новый массив.
	// Есть 2 типа задач, где оператор rest используется чаще всего – в функциях и в процессе деструктизации.

	// Пример 1. Оператор rest в функциях
		// Предположим, мы продаем пиццу. Стоимость нашей самой популярной пиццы “Маргарита” – 500 Руб.
		// У нас есть функция, которая принимает стоимость конкретной пиццы и количество заказанной пиццы от разных посетителей:
		// Пример: Стоимость = 500, посетитель A заказал 3 штуки, посетитель B – 10 штук, посетитель C – 6 штук, D – 20 штук.
		// Мы будем записывать стоимость пиццы в переменную price, а количество пицц в переменную rest (можно назвать как угодно).
			
			function buyPizza(price, ...rest) {
				console.log(price); // 500
				console.log(rest);// Array(4) [ 3, 10, 6, 20 ]
				return rest.map((quantity) => {
					return price * quantity;
				  });
			}
			buyPizza(500, 3, 10, 6, 20); // Array(4) [ 1500, 5000, 3000, 10000 ]

	// Пример 2. Оператор rest и деструктуризация
		// Предположим, у нас есть массив, в котором содержится название пиццы, ее 'ID' в нашей системе заказов и количества заказанной пиццы для разных посетителей:
		// const pizza = ['Pepperoni', 2222, 5, 6, 10, 30, 1];
		// Мы можем получить название пиццы, ее ID и количества и присвоить 3-м новым переменным, используя оператор rest в процессе деструктуризации.
			
			const pizza = ['Pepperoni', 2222, 5, 6, 10, 30, 1];
			const [nameP, id, ...rest] = pizza;
			console.log(nameP); // Pepperoni
			console.log(id); // 2222
			console.log(rest); // [ 5, 6, 10, 30, 1 ]
			
		// Таким образом мы собрали все количества заказанной пиццы и создали из них отдельный новый массив.


// Сборка мусора - выполняется автоматически. Мы не можем ускорить или предотвратить её.

/*
	Достижимость
  Основной концепцией управления памятью в JavaScript является принцип достижимости. Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

	Существует базовое множество достижимых значений, которые не могут быть удалены.
	Например:
	* Выполняемая в данный момент функция, её локальные переменные и параметры.
	* Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
	* Глобальные переменные.
	* (некоторые другие внутренние значения) Эти значения мы будем называть корнями.

В движке JavaScript есть фоновый процесс, который называется сборщиком мусора. Он отслеживает все объекты и удаляет те, которые стали недоступными.

*/

// в user находится ссылка на объект
	let userTrash = {
		name: "John"
	};

// Глобальная переменная userTrash ссылается на объект {name: "John"} (мы будем называть его просто «John» для краткости). В свойстве "name" объекта John хранится примитив, поэтому оно нарисовано внутри объекта.

// Если перезаписать значение user, то ссылка потеряется:
	userTrash = null;

// Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. Сборщик мусора удалит эти данные и освободит память.



// WeakMap - первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:
// 			 если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

	let cache = new WeakMap();

	function cacheUser(obj) {
	if (!cache.has(obj)) {
		cache.set(obj, Date.now());
	}

	return cache.get(obj);
	}

	let lena = {name: 'Elena'}; 
	let alex = {name: 'Alex'} 

	cacheUser(lena);
	cacheUser(alex);

	lena = null;

	console.log(cache.has(lena));
	console.log(cache.has(alex));
/*
	WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.
			В WeakMap присутствуют только следующие методы:
				weakMap.get(key)
				weakMap.set(key, value)
				weakMap.delete(key)
				weakMap.has(key)
*/

// WeakSet - подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

	let visitedSet = new WeakSet();

	let john = { name: "John" };
	let pete = { name: "Pete" };
	let mary = { name: "Mary" };

	visitedSet.add(john); // John заходил к нам
	visitedSet.add(pete); // потом Pete
	visitedSet.add(john); // John снова

	// visitedSet сейчас содержит двух пользователей

	// проверим, заходил ли John?
	console.log(visitedSet.has(john)); // true

	// проверим, заходила ли Mary?
	console.log(visitedSet.has(mary)); // false

	john = null;
	// структура данных visitedSet будет очищена автоматически (объект john будет удалён из visitedSet)

	console.log(visitedSet.has(john)); // false

/*
	* Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
    * Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
    * Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.

Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.

*/


// Дата и время
	// Новый встроенный объект - Date. Он содержит дату и время, а также предоставляет методы управления ими.
	// Например, его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты.

	let nowDate = new Date();
	console.log(nowDate); // показывает текущие дату и время

	// new Date(year, month, date, hours, minutes, seconds, ms)
	// new Date(2011, 0, 1, 0, 0, 0, 0);  // 1 Jan 2011, 00:00:00
	// Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.
	
	/*
		year должен состоять из четырёх цифр. Для совместимости также принимаются 2 цифры и рассматриваются как 19xx, к примеру, 98 здесь это тоже самое, что и 1998, но настоятельно рекомендуется всегда использовать 4 цифры.
		month начинается с 0 (январь) по 11 (декабрь).
		Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
		Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.
	*/ 
	
	

	// Получение компонентов даты
		// getFullYear() - Получить год (4 цифры)
		// getMonth() - Получить месяц, от 0 до 11.
		// getDate() - Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
		// getHours(), getMinutes(), getSeconds(), getMilliseconds() - Получить, соответственно, часы, минуты, секунды или миллисекунды.
		// getDay() - вернуть день недели от 0 (воскресенье) до 6 (суббота). 
		// Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.

	// Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".

	// Установка компонентов даты
		// setFullYear(year, [month], [date])
		// setMonth(month, [date])
		// setDate(date)
		// setHours(hour, [min], [sec], [ms])
		// setMinutes(min, [sec], [ms])
		// setSeconds(sec, [ms])
		// setMilliseconds(ms)
	// setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
	// У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().



// Конструктор, оператор "new"
// Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню, товары магазинах и так далее. Это можно сделать при помощи функции-конструктора и оператора "new".
// https://learn.javascript.ru/constructor-new#vozvrat-znacheniya-iz-konstruktora-return


// Функция-конструктор
// Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
	//  * Имя функции-конструктора должно начинаться с большой буквы.
	//  * Функция-конструктор должна выполняться только с помощью оператора "new".

	function User12(name) {
		this.name = name;
		this.isAdmin = false;
	}
	
	  let userCon = new User12("Jack");
	  console.log(userCon); // Jack
	//  При вызыва функции new User(...), Создаётся новый пустой объект, выполняется тело функции с помощью this, добавляя туда новые свойства, возвращается значение this.

	// Теперь, если нам будет необходимо создать других пользователей, мы можем просто вызвать new User("Ann"), new User("Alice") и так далее. Данная конструкция гораздо удобнее и читабельнее, чем многократное создание литерала объекта.
	// Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов.

// Возврат значения из конструктора, return
	// Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.
		// Но если return всё же есть, то применяется простое правило:
			// * При вызове return с объектом, вместо this вернётся объект.
			// * При вызове return с примитивным значением, оно проигнорируется.
			// * Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

	// К примеру, здесь return замещает this, возвращая объект:
		function BigUser() {
			this.name = "John";
			return { name: "Godzilla" };  // <-- возвращает этот объект
		}

		console.log( new BigUser().name );  // Godzilla, получили этот объект


// Контекс вызова this.
// https://tproger.ru/translations/javascript-this-keyword/#51thisinindirectinvocation
// С точки зрения Java, PHP или любого другого обычного языка this расценивается как экземпляр текущего объекта в методе класса, не больше и не меньше. Чаще всего его нельзя использовать вне метода, и этот подход не вызывает непонимания.
/*
	В JavaScript this — это текущий контекст исполнения функции. Поскольку функцию можно вызвать четырьмя способами:

	* вызов функции: alert('Hello World!'),
		обычная функция: this = window, но если use strict - underfined
	* вызов метода: console.log('Hello World!'),
		контекст у метода объекта  - сам объект
	* вызов конструктора: new RegExp('\\d'),
		this в конструкторах и классах - это новый экземпляр объекта
	* непрямой (ручной) вызов: alert.call(undefined, 'Hello World!'),
		ручная привязка this: call, apply, bind	

	и каждый из них определяет свой контекст, поведение this слегка не соответствует ожиданиям начинающих разработчиков. Кроме того, strict mode также влияет на контекст исполнения.

Ключом к пониманию ключевого слова this является осознание принципов вызова функции и его влияния на контекст. В этой статье рассказывается про вызовы функций, влияние вызовов на this и типичные ловушки при идентификации контекста.

   	* Вызов — это исполнение кода тела функции. Например, вызовом функции parseInt будет parseInt('15').
 	* Контекстом вызова является значение this в теле функции.
	* Область видимости функции — это набор переменных, объектов и функций, к которым можно получить доступ из тела функции.

*/